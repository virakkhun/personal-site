{
  "version": 3,
  "sources": ["../../hast-util-is-element/index.js", "../../hast-util-embedded/lib/index.js", "../../rehype-minify-whitespace/block.js", "../../rehype-minify-whitespace/content.js", "../../rehype-minify-whitespace/skippable.js", "../../rehype-minify-whitespace/index.js", "../../hast-util-has-property/lib/index.js", "../../hast-util-is-body-ok-link/index.js", "../../hast-util-phrasing/lib/index.js", "../../html-whitespace-sensitive-tag-names/index.js", "../../rehype-format/index.js"],
  "sourcesContent": ["/**\n * @typedef {import('unist').Parent} Parent\n * @typedef {import('hast').Element} Element\n */\n\n/**\n * @typedef {null | undefined | string | TestFunctionAnything | Array<string | TestFunctionAnything>} Test\n *   Check for an arbitrary element, unaware of TypeScript inferral.\n *\n * @callback TestFunctionAnything\n *   Check if an element passes a test, unaware of TypeScript inferral.\n * @param {Element} element\n *   An element.\n * @param {number | null | undefined} [index]\n *   The element’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The element’s parent.\n * @returns {boolean | void}\n *   Whether this element passes the test.\n */\n\n/**\n * @template {Element} T\n *   Element type.\n * @typedef {T['tagName'] | TestFunctionPredicate<T> | Array<T['tagName'] | TestFunctionPredicate<T>>} PredicateTest\n *   Check for an element that can be inferred by TypeScript.\n */\n\n/**\n * Check if an element passes a certain node test.\n *\n * @template {Element} T\n *   Element type.\n * @callback TestFunctionPredicate\n *   Complex test function for an element that can be inferred by TypeScript.\n * @param {Element} element\n *   An element.\n * @param {number | null | undefined} [index]\n *   The element’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The element’s parent.\n * @returns {element is T}\n *   Whether this element passes the test.\n */\n\n/**\n * @callback AssertAnything\n *   Check that an arbitrary value is an element, unaware of TypeScript inferral.\n * @param {unknown} [node]\n *   Anything (typically a node).\n * @param {number | null | undefined} [index]\n *   The node’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The node’s parent.\n * @returns {boolean}\n *   Whether this is an element and passes a test.\n */\n\n/**\n * Check if a node is an element and passes a certain node test\n *\n * @template {Element} T\n *   Element type.\n * @callback AssertPredicate\n *   Check that an arbitrary value is a specific element, aware of TypeScript.\n * @param {unknown} [node]\n *   Anything (typically a node).\n * @param {number | null | undefined} [index]\n *   The node’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The node’s parent.\n * @returns {node is T}\n *   Whether this is an element and passes a test.\n */\n\n/**\n * Check if `node` is an `Element` and whether it passes the given test.\n *\n * @param node\n *   Thing to check, typically `Node`.\n * @param test\n *   A check for a specific element.\n * @param index\n *   The node’s position in its parent.\n * @param parent\n *   The node’s parent.\n * @returns\n *   Whether `node` is an element and passes a test.\n */\nexport const isElement =\n  /**\n   * @type {(\n   *   (() => false) &\n   *   (<T extends Element = Element>(node: unknown, test?: PredicateTest<T>, index?: number, parent?: Parent, context?: unknown) => node is T) &\n   *   ((node: unknown, test: Test, index?: number, parent?: Parent, context?: unknown) => boolean)\n   * )}\n   */\n  (\n    /**\n     * @param {unknown} [node]\n     * @param {Test | undefined} [test]\n     * @param {number | null | undefined} [index]\n     * @param {Parent | null | undefined} [parent]\n     * @param {unknown} [context]\n     * @returns {boolean}\n     */\n    // eslint-disable-next-line max-params\n    function (node, test, index, parent, context) {\n      const check = convertElement(test)\n\n      if (\n        index !== undefined &&\n        index !== null &&\n        (typeof index !== 'number' ||\n          index < 0 ||\n          index === Number.POSITIVE_INFINITY)\n      ) {\n        throw new Error('Expected positive finite index for child node')\n      }\n\n      if (\n        parent !== undefined &&\n        parent !== null &&\n        (!parent.type || !parent.children)\n      ) {\n        throw new Error('Expected parent node')\n      }\n\n      // @ts-expect-error Looks like a node.\n      if (!node || !node.type || typeof node.type !== 'string') {\n        return false\n      }\n\n      if (\n        (parent === undefined || parent === null) !==\n        (index === undefined || index === null)\n      ) {\n        throw new Error('Expected both parent and index')\n      }\n\n      return check.call(context, node, index, parent)\n    }\n  )\n\n/**\n * Generate an assertion from a test.\n *\n * Useful if you’re going to test many nodes, for example when creating a\n * utility where something else passes a compatible test.\n *\n * The created function is a bit faster because it expects valid input only:\n * a `node`, `index`, and `parent`.\n *\n * @param test\n *   *  When nullish, checks if `node` is an `Element`.\n *   *  When `string`, works like passing `(element) => element.tagName === test`.\n *   *  When `function` checks if function passed the element is true.\n *   *  When `array`, checks any one of the subtests pass.\n * @returns\n *   An assertion.\n */\nexport const convertElement =\n  /**\n   * @type {(\n   *   (<T extends Element>(test: T['tagName'] | TestFunctionPredicate<T>) => AssertPredicate<T>) &\n   *   ((test?: Test) => AssertAnything)\n   * )}\n   */\n  (\n    /**\n     * @param {Test | null | undefined} [test]\n     * @returns {AssertAnything}\n     */\n    function (test) {\n      if (test === undefined || test === null) {\n        return element\n      }\n\n      if (typeof test === 'string') {\n        return tagNameFactory(test)\n      }\n\n      if (typeof test === 'object') {\n        return anyFactory(test)\n      }\n\n      if (typeof test === 'function') {\n        return castFactory(test)\n      }\n\n      throw new Error('Expected function, string, or array as test')\n    }\n  )\n\n/**\n * Handle multiple tests.\n *\n * @param {Array<string | TestFunctionAnything>} tests\n * @returns {AssertAnything}\n */\nfunction anyFactory(tests) {\n  /** @type {Array<AssertAnything>} */\n  const checks = []\n  let index = -1\n\n  while (++index < tests.length) {\n    checks[index] = convertElement(tests[index])\n  }\n\n  return castFactory(any)\n\n  /**\n   * @this {unknown}\n   * @param {Array<unknown>} parameters\n   * @returns {boolean}\n   */\n  function any(...parameters) {\n    let index = -1\n\n    while (++index < checks.length) {\n      if (checks[index].call(this, ...parameters)) {\n        return true\n      }\n    }\n\n    return false\n  }\n}\n\n/**\n * Turn a string into a test for an element with a certain tag name.\n *\n * @param {string} check\n * @returns {AssertAnything}\n */\nfunction tagNameFactory(check) {\n  return tagName\n\n  /**\n   * @param {unknown} node\n   * @returns {boolean}\n   */\n  function tagName(node) {\n    return element(node) && node.tagName === check\n  }\n}\n\n/**\n * Turn a custom test into a test for an element that passes that test.\n *\n * @param {TestFunctionAnything} check\n * @returns {AssertAnything}\n */\nfunction castFactory(check) {\n  return assertion\n\n  /**\n   * @this {unknown}\n   * @param {unknown} node\n   * @param {Array<unknown>} parameters\n   * @returns {boolean}\n   */\n  function assertion(node, ...parameters) {\n    // @ts-expect-error: fine.\n    return element(node) && Boolean(check.call(this, node, ...parameters))\n  }\n}\n\n/**\n * Make sure something is an element.\n *\n * @param {unknown} node\n * @returns {node is Element}\n */\nfunction element(node) {\n  return Boolean(\n    node &&\n      typeof node === 'object' &&\n      // @ts-expect-error Looks like a node.\n      node.type === 'element' &&\n      // @ts-expect-error Looks like an element.\n      typeof node.tagName === 'string'\n  )\n}\n", "/**\n * @typedef {import('hast').Element} Element\n */\n\nimport {convertElement} from 'hast-util-is-element'\n\n/**\n * Check if a node is a *embedded content*.\n *\n * @type {import('hast-util-is-element').AssertPredicate<Element & {tagName: 'audio' | 'canvas' | 'embed' | 'iframe' | 'img' | 'math' | 'object' | 'picture' | 'svg' | 'video'}>}\n * @param value\n *   Thing to check (typically `Node`).\n * @returns\n *   Whether `value` is an element considered embedded content.\n *\n *   The elements `audio`, `canvas`, `embed`, `iframe`, `img`, `math`,\n *   `object`, `picture`, `svg`, and `video` are embedded content.\n */\n// @ts-expect-error Sure, the assertion matches.\nexport const embedded = convertElement([\n  'audio',\n  'canvas',\n  'embed',\n  'iframe',\n  'img',\n  'math',\n  'object',\n  'picture',\n  'svg',\n  'video'\n])\n", "// See: <https://html.spec.whatwg.org/#the-css-user-agent-style-sheet-and-presentational-hints>\nexport const blocks = [\n  'address', // Flow content.\n  'article', // Sections and headings.\n  'aside', // Sections and headings.\n  'blockquote', // Flow content.\n  'body', // Page.\n  'br', // Contribute whitespace intrinsically.\n  'caption', // Similar to block.\n  'center', // Flow content, legacy.\n  'col', // Similar to block.\n  'colgroup', // Similar to block.\n  'dd', // Lists.\n  'dialog', // Flow content.\n  'dir', // Lists, legacy.\n  'div', // Flow content.\n  'dl', // Lists.\n  'dt', // Lists.\n  'figcaption', // Flow content.\n  'figure', // Flow content.\n  'footer', // Flow content.\n  'form', // Flow content.\n  'h1', // Sections and headings.\n  'h2', // Sections and headings.\n  'h3', // Sections and headings.\n  'h4', // Sections and headings.\n  'h5', // Sections and headings.\n  'h6', // Sections and headings.\n  'head', // Page.\n  'header', // Flow content.\n  'hgroup', // Sections and headings.\n  'hr', // Flow content.\n  'html', // Page.\n  'legend', // Flow content.\n  'li', // Block-like.\n  'li', // Similar to block.\n  'listing', // Flow content, legacy\n  'main', // Flow content.\n  'menu', // Lists.\n  'nav', // Sections and headings.\n  'ol', // Lists.\n  'optgroup', // Similar to block.\n  'option', // Similar to block.\n  'p', // Flow content.\n  'plaintext', // Flow content, legacy\n  'pre', // Flow content.\n  'section', // Sections and headings.\n  'summary', // Similar to block.\n  'table', // Similar to block.\n  'tbody', // Similar to block.\n  'td', // Block-like.\n  'td', // Similar to block.\n  'tfoot', // Similar to block.\n  'th', // Block-like.\n  'th', // Similar to block.\n  'thead', // Similar to block.\n  'tr', // Similar to block.\n  'ul', // Lists.\n  'wbr', // Contribute whitespace intrinsically.\n  'xmp' // Flow content, legacy\n]\n", "export const content = [\n  // Form.\n  'button',\n  'input',\n  'select',\n  'textarea'\n]\n", "export const skippable = [\n  'area',\n  'base',\n  'basefont',\n  'dialog',\n  'datalist',\n  'head',\n  'link',\n  'meta',\n  'noembed',\n  'noframes',\n  'param',\n  'rp',\n  'script',\n  'source',\n  'style',\n  'template',\n  'track',\n  'title'\n]\n", "/**\n * rehype plugin to minify whitespace between elements.\n *\n * ## What is this?\n *\n * This package is a plugin that can minify the whitespace between elements.\n *\n * ## When should I use this?\n *\n * You can use this plugin when you want to improve the size of HTML documents.\n *\n * ## API\n *\n * ### `unified().use(rehypeMinifyWhitespace[, options])`\n *\n * Minify whitespace.\n *\n * ##### `options`\n *\n * Configuration (optional).\n *\n * ##### `options.newlines`\n *\n * Whether to collapse runs of whitespace that include line endings to one\n * line ending (`boolean`, default: `false`).\n * The default is to collapse everything to one space.\n *\n * @example\n *   <h1>Heading</h1>\n *   <p><strong>This</strong> and <em>that</em></p>\n */\n\n/**\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Text} Text\n * @typedef {Root|Root['children'][number]} Node\n *\n * @typedef Options\n * @property {boolean} [newlines=false]\n *   If `newlines: true`, collapses whitespace containing newlines to `'\\n'`\n *   instead of `' '`.\n *   The default is to collapse to a single space.\n *\n * @typedef {'pre'|'nowrap'|'pre-wrap'|'normal'} Whitespace\n *\n * @typedef Context\n * @property {ReturnType<collapseFactory>} collapse\n * @property {Whitespace} whitespace\n * @property {boolean} [before]\n * @property {boolean} [after]\n *\n * @typedef Result\n * @property {boolean} remove\n * @property {boolean} ignore\n * @property {boolean} stripAtStart\n */\n\nimport {isElement} from 'hast-util-is-element'\nimport {embedded} from 'hast-util-embedded'\nimport {convert} from 'unist-util-is'\nimport {whitespace} from 'hast-util-whitespace'\nimport {blocks} from './block.js'\nimport {content as contents} from './content.js'\nimport {skippable as skippables} from './skippable.js'\n\nconst ignorableNode = convert(['doctype', 'comment'])\n\n/**\n * Minify whitespace.\n *\n * @type {import('unified').Plugin<[Options?]|Array<void>, Root>}\n */\nexport default function rehypeMinifyWhitespace(options = {}) {\n  const collapse = collapseFactory(\n    options.newlines ? replaceNewlines : replaceWhitespace\n  )\n\n  return (tree) => {\n    minify(tree, {collapse, whitespace: 'normal'})\n  }\n}\n\n/**\n * @param {Node} node\n * @param {Context} context\n * @returns {Result}\n */\nfunction minify(node, context) {\n  if ('children' in node) {\n    const settings = Object.assign({}, context)\n\n    if (node.type === 'root' || blocklike(node)) {\n      settings.before = true\n      settings.after = true\n    }\n\n    settings.whitespace = inferWhiteSpace(node, context)\n\n    return all(node, settings)\n  }\n\n  if (node.type === 'text') {\n    if (context.whitespace === 'normal') {\n      return minifyText(node, context)\n    }\n\n    // Naïve collapse, but no trimming:\n    if (context.whitespace === 'nowrap') {\n      node.value = context.collapse(node.value)\n    }\n\n    // The `pre-wrap` or `pre` whitespace settings are neither collapsed nor\n    // trimmed.\n  }\n\n  return {remove: false, ignore: ignorableNode(node), stripAtStart: false}\n}\n\n/**\n * @param {Text} node\n * @param {Context} context\n * @returns {Result}\n */\nfunction minifyText(node, context) {\n  const value = context.collapse(node.value)\n  const result = {remove: false, ignore: false, stripAtStart: false}\n  let start = 0\n  let end = value.length\n\n  if (context.before && removable(value.charAt(0))) {\n    start++\n  }\n\n  if (start !== end && removable(value.charAt(end - 1))) {\n    if (context.after) {\n      end--\n    } else {\n      result.stripAtStart = true\n    }\n  }\n\n  if (start === end) {\n    result.remove = true\n  } else {\n    node.value = value.slice(start, end)\n  }\n\n  return result\n}\n\n/**\n * @param {Root|Element} parent\n * @param {Context} context\n * @returns {Result}\n */\nfunction all(parent, context) {\n  let before = context.before\n  const after = context.after\n  const children = parent.children\n  let length = children.length\n  let index = -1\n\n  while (++index < length) {\n    const result = minify(\n      children[index],\n      Object.assign({}, context, {\n        before,\n        after: collapsableAfter(children, index, after)\n      })\n    )\n\n    if (result.remove) {\n      children.splice(index, 1)\n      index--\n      length--\n    } else if (!result.ignore) {\n      before = result.stripAtStart\n    }\n\n    // If this element, such as a `<select>` or `<img>`, contributes content\n    // somehow, allow whitespace again.\n    if (content(children[index])) {\n      before = false\n    }\n  }\n\n  return {remove: false, ignore: false, stripAtStart: Boolean(before || after)}\n}\n\n/**\n * @param {Array<Node>} nodes\n * @param {number} index\n * @param {boolean|undefined} [after]\n * @returns {boolean|undefined}\n */\nfunction collapsableAfter(nodes, index, after) {\n  while (++index < nodes.length) {\n    const node = nodes[index]\n    let result = inferBoundary(node)\n\n    if (result === undefined && 'children' in node && !skippable(node)) {\n      result = collapsableAfter(node.children, -1)\n    }\n\n    if (typeof result === 'boolean') {\n      return result\n    }\n  }\n\n  return after\n}\n\n/**\n * Infer two types of boundaries:\n *\n * 1. `true` — boundary for which whitespace around it does not contribute\n *    anything\n * 2. `false` — boundary for which whitespace around it *does* contribute\n *\n * No result (`undefined`) is returned if it is unknown.\n *\n * @param {Node} node\n * @returns {boolean|undefined}\n */\nfunction inferBoundary(node) {\n  if (node.type === 'element') {\n    if (content(node)) {\n      return false\n    }\n\n    if (blocklike(node)) {\n      return true\n    }\n\n    // Unknown: either depends on siblings if embedded or metadata, or on\n    // children.\n  } else if (node.type === 'text') {\n    if (!whitespace(node)) {\n      return false\n    }\n  } else if (!ignorableNode(node)) {\n    return false\n  }\n}\n\n/**\n * Infer whether a node is skippable.\n *\n * @param {Node} node\n * @returns {boolean}\n */\nfunction content(node) {\n  return embedded(node) || isElement(node, contents)\n}\n\n/**\n * See: <https://html.spec.whatwg.org/#the-css-user-agent-style-sheet-and-presentational-hints>\n *\n * @param {Element} node\n * @returns {boolean}\n */\nfunction blocklike(node) {\n  return isElement(node, blocks)\n}\n\n/**\n * @param {Element|Root} node\n * @returns {boolean}\n */\nfunction skippable(node) {\n  return (\n    Boolean(\n      'properties' in node && node.properties && node.properties.hidden\n    ) ||\n    ignorableNode(node) ||\n    isElement(node, skippables)\n  )\n}\n\n/**\n * @param {string} character\n * @returns {boolean}\n */\nfunction removable(character) {\n  return character === ' ' || character === '\\n'\n}\n\n/**\n * @param {string} value\n * @returns {string}\n */\nfunction replaceNewlines(value) {\n  const match = /\\r?\\n|\\r/.exec(value)\n  return match ? match[0] : ' '\n}\n\n/**\n * @returns {string}\n */\nfunction replaceWhitespace() {\n  return ' '\n}\n\n/**\n * @param {(value: string) => string} replace\n */\nfunction collapseFactory(replace) {\n  return collapse\n\n  /**\n   * @param {string} value\n   * @returns {string}\n   */\n  function collapse(value) {\n    return String(value).replace(/[\\t\\n\\v\\f\\r ]+/g, replace)\n  }\n}\n\n/**\n * We don’t need to support void elements here (so `nobr wbr` -> `normal` is\n * ignored).\n *\n * @param {Root|Element} node\n * @param {Context} context\n * @returns {Whitespace}\n */\nfunction inferWhiteSpace(node, context) {\n  if ('tagName' in node && node.properties) {\n    switch (node.tagName) {\n      // Whitespace in script/style, while not displayed by CSS as significant,\n      // could have some meaning in JS/CSS, so we can’t touch them.\n      case 'listing':\n      case 'plaintext':\n      case 'script':\n      case 'style':\n      case 'xmp':\n        return 'pre'\n      case 'nobr':\n        return 'nowrap'\n      case 'pre':\n        return node.properties.wrap ? 'pre-wrap' : 'pre'\n      case 'td':\n      case 'th':\n        return node.properties.noWrap ? 'nowrap' : context.whitespace\n      case 'textarea':\n        return 'pre-wrap'\n      default:\n    }\n  }\n\n  return context.whitespace\n}\n", "/**\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').Content} Content\n */\n\n/**\n * @typedef {Root | Content} Node\n */\n\nconst own = {}.hasOwnProperty\n\n/**\n * Check if `node`is an element and has a `field` property.\n *\n * @param {unknown} node\n *   Thing to check (typically `Element`).\n * @param {unknown} field\n *   Field name to check (typically `string`).\n * @returns {boolean}\n *   Whether `node` is an element that has a `field` property.\n */\nexport function hasProperty(node, field) {\n  const value =\n    typeof field === 'string' &&\n    isNode(node) &&\n    node.type === 'element' &&\n    node.properties &&\n    own.call(node.properties, field) &&\n    node.properties[field]\n\n  return value !== null && value !== undefined && value !== false\n}\n\n/**\n * @param {unknown} value\n * @returns {value is Node}\n */\nfunction isNode(value) {\n  return Boolean(value && typeof value === 'object' && 'type' in value)\n}\n", "/**\n * @fileoverview\n *   Check if a `link` element is “Body OK”.\n * @longdescription\n *   ## Use\n *\n *   ```js\n *   import {h} from 'hastscript'\n *   import {isBodyOkLink} from 'hast-util-is-body-ok-link'\n *\n *   isBodyOkLink(h('link', {itemProp: 'foo'})) //=> true\n *   isBodyOkLink(h('link', {rel: ['stylesheet'], href: 'index.css'})) //=> true\n *   isBodyOkLink(h('link', {rel: ['author'], href: 'index.css'})) //=> false\n *   ```\n *\n *   ## API\n *\n *   ### `isBodyOkLink(node)`\n *\n *   * Return `true` for `link` elements with an `itemProp`\n *   * Return `true` for `link` elements with a `rel` list where one or more\n *     entries are `pingback`, `prefetch`, or `stylesheet`.\n */\n\nimport {isElement} from 'hast-util-is-element'\nimport {hasProperty} from 'hast-util-has-property'\n\nconst list = new Set(['pingback', 'prefetch', 'stylesheet'])\n\n/**\n * @typedef {import('hast').Root} Root\n * @typedef {Root|Root['children'][number]} Node\n */\n\n/**\n * Check if a `link` element is “Body OK”.\n *\n * @param {Node} node\n * @returns {boolean}\n */\nexport function isBodyOkLink(node) {\n  if (!isElement(node, 'link')) {\n    return false\n  }\n\n  if (hasProperty(node, 'itemProp')) {\n    return true\n  }\n\n  const props = node.properties || {}\n  const rel = props.rel || []\n  let index = -1\n\n  if (!Array.isArray(rel) || rel.length === 0) {\n    return false\n  }\n\n  while (++index < rel.length) {\n    if (!list.has(String(rel[index]))) {\n      return false\n    }\n  }\n\n  return true\n}\n", "/**\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').Content} Content\n */\n\n/**\n * @typedef {Root | Content} Node\n */\n\nimport {convertElement} from 'hast-util-is-element'\nimport {hasProperty} from 'hast-util-has-property'\nimport {embedded} from 'hast-util-embedded'\nimport {isBodyOkLink} from 'hast-util-is-body-ok-link'\n\nconst basic = convertElement([\n  'a',\n  'abbr',\n  // `area` is in fact only phrasing if it is inside a `map` element.\n  // However, since `area`s are required to be inside a `map` element, and it’s\n  // a rather involved check, it’s ignored here for now.\n  'area',\n  'b',\n  'bdi',\n  'bdo',\n  'br',\n  'button',\n  'cite',\n  'code',\n  'data',\n  'datalist',\n  'del',\n  'dfn',\n  'em',\n  'i',\n  'input',\n  'ins',\n  'kbd',\n  'keygen',\n  'label',\n  'map',\n  'mark',\n  'meter',\n  'noscript',\n  'output',\n  'progress',\n  'q',\n  'ruby',\n  's',\n  'samp',\n  'script',\n  'select',\n  'small',\n  'span',\n  'strong',\n  'sub',\n  'sup',\n  'template',\n  'textarea',\n  'time',\n  'u',\n  'var',\n  'wbr'\n])\n\nconst meta = convertElement('meta')\n\n/**\n * Check if the given value is *phrasing* content.\n *\n * @param {unknown} value\n *   Thing to check, typically `Node`.\n * @returns {boolean}\n *   Whether `value` is phrasing content.\n */\nexport function phrasing(value) {\n  return Boolean(\n    node(value) &&\n      (value.type === 'text' ||\n        basic(value) ||\n        embedded(value) ||\n        isBodyOkLink(value) ||\n        (meta(value) && hasProperty(value, 'itemProp')))\n  )\n}\n\n/**\n * @param {unknown} value\n * @returns {value is Node}\n */\nfunction node(value) {\n  // @ts-expect-error: looks like an object.\n  return value && typeof value === 'object' && 'type' in value\n}\n", "/**\n * @fileoverview\n *   List of whitespace sensitive HTML tag names\n * @longdescription\n *   ## Use\n *\n *   ```js\n *   import {whitespaceSensitiveTagNames} from 'html-whitespace-sensitive-tag-names'\n *\n *   whitespaceSensitiveTagNames\n *   //=> ['pre', 'script', 'style', 'textarea']\n *   ```\n *\n *   ## API\n *\n *   ### `whitespaceSensitiveTagNames`\n *\n *   List of whitespace sensitive HTML tag names (`string[]`).\n */\n\nexport const whitespaceSensitiveTagNames = [\n  'pre',\n  'script',\n  'style',\n  'textarea'\n]\n", "/**\n * @typedef {import('hast').Root} Root\n * @typedef {Root['children'][number]} Child\n * @typedef {import('hast').Element} Element\n * @typedef {Root|Child} Node\n *\n * @typedef Options\n *   Configuration.\n * @property {number|string} [indent=2]\n *   Indentation per level (`number`, `string`, default: `2`).\n *   When number, uses that amount of spaces.\n *   When `string`, uses that per indentation level.\n * @property {boolean} [indentInitial=true]\n *   Whether to indent the first level (`boolean`, default: `true`).\n *   This is usually the `<html>`, thus not indenting `head` and `body`.\n * @property {Array<string>} [blanks=[]]\n *   List of tag names to join with a blank line (`Array<string>`, default:\n *   `[]`).\n *   These tags, when next to each other, are joined by a blank line (`\\n\\n`).\n *   For example, when `['head', 'body']` is given, a blank line is added\n *   between these two.\n */\n\nimport rehypeMinifyWhitespace from 'rehype-minify-whitespace'\nimport {visitParents, SKIP} from 'unist-util-visit-parents'\nimport {embedded} from 'hast-util-embedded'\nimport {phrasing} from 'hast-util-phrasing'\nimport {whitespace} from 'hast-util-whitespace'\nimport {isElement} from 'hast-util-is-element'\nimport {whitespaceSensitiveTagNames} from 'html-whitespace-sensitive-tag-names'\n\nconst minify = rehypeMinifyWhitespace({newlines: true})\n\n/**\n * Format whitespace in HTML.\n *\n * @type {import('unified').Plugin<[Options?] | Array<void>, Root>}\n */\nexport default function rehypeFormat(options = {}) {\n  let indent = options.indent || 2\n  let indentInitial = options.indentInitial\n\n  if (typeof indent === 'number') {\n    indent = ' '.repeat(indent)\n  }\n\n  // Default to indenting the initial level.\n  if (indentInitial === null || indentInitial === undefined) {\n    indentInitial = true\n  }\n\n  return (tree) => {\n    /** @type {boolean|undefined} */\n    let head\n\n    // @ts-expect-error: fine, it’s a sync transformer.\n    minify(tree)\n\n    // eslint-disable-next-line complexity\n    visitParents(tree, (node, parents) => {\n      let index = -1\n\n      if (!('children' in node)) {\n        return\n      }\n\n      if (isElement(node, 'head')) {\n        head = true\n      }\n\n      if (head && isElement(node, 'body')) {\n        head = undefined\n      }\n\n      if (isElement(node, whitespaceSensitiveTagNames)) {\n        return SKIP\n      }\n\n      const children = node.children\n      let level = parents.length\n\n      // Don’t indent content of whitespace-sensitive nodes / inlines.\n      if (children.length === 0 || !padding(node, head)) {\n        return\n      }\n\n      if (!indentInitial) {\n        level--\n      }\n\n      /** @type {boolean|undefined} */\n      let eol\n\n      // Indent newlines in `text`.\n      while (++index < children.length) {\n        const child = children[index]\n\n        if (child.type === 'text' || child.type === 'comment') {\n          if (child.value.includes('\\n')) {\n            eol = true\n          }\n\n          child.value = child.value.replace(\n            / *\\n/g,\n            '$&' + String(indent).repeat(level)\n          )\n        }\n      }\n\n      /** @type {Array<Child>} */\n      const result = []\n      /** @type {Child|undefined} */\n      let previous\n\n      index = -1\n\n      while (++index < children.length) {\n        const child = children[index]\n\n        if (padding(child, head) || (eol && !index)) {\n          addBreak(result, level, child)\n          eol = true\n        }\n\n        previous = child\n        result.push(child)\n      }\n\n      if (previous && (eol || padding(previous, head))) {\n        // Ignore trailing whitespace (if that already existed), as we’ll add\n        // properly indented whitespace.\n        if (whitespace(previous)) {\n          result.pop()\n          previous = result[result.length - 1]\n        }\n\n        addBreak(result, level - 1)\n      }\n\n      node.children = result\n    })\n  }\n\n  /**\n   * @param {Array<Child>} list\n   * @param {number} level\n   * @param {Child} [next]\n   * @returns {void}\n   */\n  function addBreak(list, level, next) {\n    const tail = list[list.length - 1]\n    const previous = whitespace(tail) ? list[list.length - 2] : tail\n    const replace =\n      (blank(previous) && blank(next) ? '\\n\\n' : '\\n') +\n      String(indent).repeat(Math.max(level, 0))\n\n    if (tail && tail.type === 'text') {\n      tail.value = whitespace(tail) ? replace : tail.value + replace\n    } else {\n      list.push({type: 'text', value: replace})\n    }\n  }\n\n  /**\n   * @param {Node|undefined} node\n   * @returns {boolean}\n   */\n  function blank(node) {\n    return Boolean(\n      node &&\n        node.type === 'element' &&\n        options.blanks &&\n        options.blanks.length > 0 &&\n        options.blanks.includes(node.tagName)\n    )\n  }\n}\n\n/**\n * @param {Node} node\n * @param {boolean|undefined} head\n * @returns {boolean}\n */\nfunction padding(node, head) {\n  return (\n    node.type === 'root' ||\n    (node.type === 'element'\n      ? head || isElement(node, 'script') || embedded(node) || !phrasing(node)\n      : false)\n  )\n}\n"],
  "mappings": "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",
  "names": ["node", "index", "node", "content", "skippable", "node", "node", "minify", "node", "list"]
}
