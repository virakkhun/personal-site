{
  "version": 3,
  "sources": ["../../parse-numeric-range/index.js", "../../hast-util-to-string/index.js", "../../unist-util-filter/lib/index.js", "../../rehype-prism-plus/src/generator.js"],
  "sourcesContent": ["/**\n * @param {string} string    The string to parse\n * @returns {Array<number>}  Returns an energetic array.\n */\nfunction parsePart(string) {\n  let res = [];\n  let m;\n\n  for (let str of string.split(\",\").map((str) => str.trim())) {\n    // just a number\n    if (/^-?\\d+$/.test(str)) {\n      res.push(parseInt(str, 10));\n    } else if (\n      (m = str.match(/^(-?\\d+)(-|\\.\\.\\.?|\\u2025|\\u2026|\\u22EF)(-?\\d+)$/))\n    ) {\n      // 1-5 or 1..5 (equivalent) or 1...5 (doesn't include 5)\n      let [_, lhs, sep, rhs] = m;\n\n      if (lhs && rhs) {\n        lhs = parseInt(lhs);\n        rhs = parseInt(rhs);\n        const incr = lhs < rhs ? 1 : -1;\n\n        // Make it inclusive by moving the right 'stop-point' away by one.\n        if (sep === \"-\" || sep === \"..\" || sep === \"\\u2025\") rhs += incr;\n\n        for (let i = lhs; i !== rhs; i += incr) res.push(i);\n      }\n    }\n  }\n\n  return res;\n}\n\nexports.default = parsePart;\nmodule.exports = parsePart;\n", "/**\n * @fileoverview\n *   Get the plain-text value of a hast node.\n * @longdescription\n *   ## Use\n *\n *   ```js\n *   import {h} from 'hastscript'\n *   import {toString} from 'hast-util-to-string'\n *\n *   toString(h('p', 'Alpha'))\n *   //=> 'Alpha'\n *   toString(h('div', [h('b', 'Bold'), ' and ', h('i', 'italic'), '.']))\n *   //=> 'Bold and italic.'\n *   ```\n *\n *   ## API\n *\n *   ### `toString(node)`\n *\n *   Transform a node to a string.\n */\n\n/**\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').Element} Element\n * @typedef {Root|Root['children'][number]} Node\n */\n\n/**\n * Get the plain-text value of a hast node.\n *\n * @param {Node} node\n * @returns {string}\n */\nexport function toString(node) {\n  // “The concatenation of data of all the Text node descendants of the context\n  // object, in tree order.”\n  if ('children' in node) {\n    return all(node)\n  }\n\n  // “Context object’s data.”\n  return 'value' in node ? node.value : ''\n}\n\n/**\n * @param {Node} node\n * @returns {string}\n */\nfunction one(node) {\n  if (node.type === 'text') {\n    return node.value\n  }\n\n  return 'children' in node ? all(node) : ''\n}\n\n/**\n * @param {Root|Element} node\n * @returns {string}\n */\nfunction all(node) {\n  let index = -1\n  /** @type {string[]} */\n  const result = []\n\n  while (++index < node.children.length) {\n    result[index] = one(node.children[index])\n  }\n\n  return result.join('')\n}\n", "/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n * @typedef {import('unist-util-is').Test} Test\n *\n * @typedef Options\n *   Configuration (optional).\n * @property {boolean | null | undefined} [cascade=true]\n *   Whether to drop parent nodes if they had children, but all their children\n *   were filtered out.\n */\n\nimport {convert} from 'unist-util-is'\n\nconst own = {}.hasOwnProperty\n\n/**\n * Create a new `tree` of copies of all nodes that pass `test`.\n *\n * The tree is walked in *preorder* (NLR), visiting the node itself, then its\n * head, etc.\n *\n * @param tree\n *   Tree to filter.\n * @param options\n *   Configuration (optional).\n * @param test\n *   `unist-util-is` compatible test.\n * @returns\n *   New filtered tree.\n *\n *   `null` is returned if `tree` itself didn’t pass the test, or is cascaded\n *   away.\n */\nexport const filter =\n  /**\n   * @type {(\n   *  (<Tree extends Node, Check extends Test>(node: Tree, options: Options | null | undefined, test: Check | null | undefined) => import('./complex-types.js').Matches<Tree, Check>) &\n   *  (<Tree extends Node, Check extends Test>(node: Tree, test: Check) => import('./complex-types.js').Matches<Tree, Check>) &\n   *  (<Tree extends Node>(node: Tree, options?: Options | null | undefined) => Tree)\n   * )}\n   */\n  (\n    /**\n     * @param {Node} tree\n     * @param {Options | Test | null | undefined} [options]\n     * @param {Test | null | undefined} [test]\n     * @returns {Node | null}\n     */\n    function (tree, options, test) {\n      const is = convert(test || options)\n      /** @type {boolean | null | undefined} */\n      const cascadeRaw =\n        options && typeof options === 'object' && 'cascade' in options\n          ? /** @type {boolean | null | undefined} */ (options.cascade)\n          : undefined\n      const cascade =\n        cascadeRaw === undefined || cascadeRaw === null ? true : cascadeRaw\n\n      return preorder(tree)\n\n      /**\n       * @param {Node} node\n       *   Current node.\n       * @param {number | undefined} [index]\n       *   Index of `node` in `parent`.\n       * @param {Parent | undefined} [parent]\n       *   Parent node.\n       * @returns {Node | null}\n       *   Shallow copy of `node`.\n       */\n      function preorder(node, index, parent) {\n        /** @type {Array<Node>} */\n        const children = []\n\n        if (!is(node, index, parent)) return null\n\n        // @ts-expect-error: Looks like a parent.\n        if (node.children) {\n          let childIndex = -1\n\n          // @ts-expect-error Looks like a parent.\n          while (++childIndex < node.children.length) {\n            // @ts-expect-error Looks like a parent.\n            const result = preorder(node.children[childIndex], childIndex, node)\n\n            if (result) {\n              children.push(result)\n            }\n          }\n\n          // @ts-expect-error Looks like a parent.\n          if (cascade && node.children.length > 0 && children.length === 0)\n            return null\n        }\n\n        // Create a shallow clone, using the new children.\n        /** @type {typeof node} */\n        // @ts-expect-error all the fields will be copied over.\n        const next = {}\n        /** @type {string} */\n        let key\n\n        for (key in node) {\n          if (own.call(node, key)) {\n            // @ts-expect-error: Looks like a record.\n            next[key] = key === 'children' ? children : node[key]\n          }\n        }\n\n        return next\n      }\n    }\n  )\n", "/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Root} Root\n * @typedef Options options\n *   Configuration.\n * @property {boolean} [showLineNumbers]\n *   Set `showLineNumbers` to `true` to always display line number\n * @property {boolean} [ignoreMissing]\n *   Set `ignoreMissing` to `true` to ignore unsupported languages and line highlighting when no language is specified\n * @property {string} [defaultLanguage]\n *   Uses the specified language as the default if none is specified. Takes precedence over `ignoreMissing`.\n *   Note: The language must be registered with refractor.\n */\n\nimport { visit } from 'unist-util-visit'\nimport { toString } from 'hast-util-to-string'\nimport { filter } from 'unist-util-filter'\nimport rangeParser from 'parse-numeric-range'\n\nconst getLanguage = (node) => {\n  const className = node.properties.className\n  //@ts-ignore\n  for (const classListItem of className) {\n    if (classListItem.slice(0, 9) === 'language-') {\n      return classListItem.slice(9).toLowerCase()\n    }\n  }\n  return null\n}\n\n/**\n * @param {import('refractor/lib/core').Refractor} refractor\n * @param {string} defaultLanguage\n * @return {void}\n */\nconst checkIfLanguageIsRegistered = (refractor, defaultLanguage) => {\n  if (defaultLanguage && !refractor.registered(defaultLanguage)) {\n    throw new Error(`The default language \"${defaultLanguage}\" is not registered with refractor.`)\n  }\n}\n\n/**\n * Create a closure that determines if we have to highlight the given index\n *\n * @param {string} meta\n * @return { (index:number) => boolean }\n */\nconst calculateLinesToHighlight = (meta) => {\n  const RE = /{([\\d,-]+)}/\n  // Remove space between {} e.g. {1, 3}\n  const parsedMeta = meta\n    .split(',')\n    .map((str) => str.trim())\n    .join()\n  if (RE.test(parsedMeta)) {\n    const strlineNumbers = RE.exec(parsedMeta)[1]\n    const lineNumbers = rangeParser(strlineNumbers)\n    return (index) => lineNumbers.includes(index + 1)\n  } else {\n    return () => false\n  }\n}\n\n/**\n * Check if we want to start the line numbering from a given number or 1\n * showLineNumbers=5, will start the numbering from 5\n * @param {string} meta\n * @returns {number}\n */\nconst calculateStartingLine = (meta) => {\n  const RE = /showLineNumbers=(?<lines>\\d+)/i\n  // pick the line number after = using a named capturing group\n  if (RE.test(meta)) {\n    const {\n      groups: { lines },\n    } = RE.exec(meta)\n    return Number(lines)\n  }\n  return 1\n}\n\n/**\n * Create container AST for node lines\n *\n * @param {number} number\n * @return {Element[]}\n */\nconst createLineNodes = (number) => {\n  const a = new Array(number)\n  for (let i = 0; i < number; i++) {\n    a[i] = {\n      type: 'element',\n      tagName: 'span',\n      properties: { className: [] },\n      children: [],\n    }\n  }\n  return a\n}\n\n/**\n * Split multiline text nodes into individual nodes with positioning\n * Add a node start and end line position information for each text node\n *\n * @return { (ast:Element['children']) => Element['children'] }\n *\n */\nconst addNodePositionClosure = () => {\n  let startLineNum = 1\n  /**\n   * @param {Element['children']} ast\n   * @return {Element['children']}\n   */\n  const addNodePosition = (ast) => {\n    return ast.reduce((result, node) => {\n      if (node.type === 'text') {\n        const value = /** @type {string} */ (node.value)\n        const numLines = (value.match(/\\n/g) || '').length\n        if (numLines === 0) {\n          node.position = {\n            // column: 1 is needed to avoid error with @next/mdx\n            // https://github.com/timlrx/rehype-prism-plus/issues/44\n            start: { line: startLineNum, column: 1 },\n            end: { line: startLineNum, column: 1 },\n          }\n          result.push(node)\n        } else {\n          const lines = value.split('\\n')\n          for (const [i, line] of lines.entries()) {\n            result.push({\n              type: 'text',\n              value: i === lines.length - 1 ? line : line + '\\n',\n              position: {\n                start: { line: startLineNum + i, column: 1 },\n                end: { line: startLineNum + i, column: 1 },\n              },\n            })\n          }\n        }\n        startLineNum = startLineNum + numLines\n\n        return result\n      }\n\n      if (Object.prototype.hasOwnProperty.call(node, 'children')) {\n        const initialLineNum = startLineNum\n        // @ts-ignore\n        node.children = addNodePosition(node.children, startLineNum)\n        result.push(node)\n        node.position = {\n          start: { line: initialLineNum, column: 1 },\n          end: { line: startLineNum, column: 1 },\n        }\n        return result\n      }\n\n      result.push(node)\n      return result\n    }, [])\n  }\n  return addNodePosition\n}\n\n/**\n * Rehype prism plugin generator that highlights code blocks with refractor (prismjs)\n *\n * Pass in your own refractor object with the required languages registered:\n * https://github.com/wooorm/refractor#refractorregistersyntax\n *\n * @param {import('refractor/lib/core').Refractor} refractor\n * @return {import('unified').Plugin<[Options?], Root>}\n */\nconst rehypePrismGenerator = (refractor) => {\n  return (options = {}) => {\n    checkIfLanguageIsRegistered(refractor, options.defaultLanguage)\n    return (tree) => {\n      visit(tree, 'element', visitor)\n    }\n\n    /**\n     * @param {Element} node\n     * @param {number} index\n     * @param {Element} parent\n     */\n    function visitor(node, index, parent) {\n      if (!parent || parent.tagName !== 'pre' || node.tagName !== 'code') {\n        return\n      }\n\n      let meta = /** @type {string} */ (node?.data?.meta || node?.properties?.metastring || '')\n      // Coerce className to array\n      if (node.properties.className) {\n        if (typeof node.properties.className === 'boolean') {\n          node.properties.className = []\n        } else if (!Array.isArray(node.properties.className)) {\n          node.properties.className = [node.properties.className]\n        }\n      } else {\n        node.properties.className = []\n      }\n\n      let lang = getLanguage(node)\n      // If no language is set on the code block, use defaultLanguage if specified\n      if (!lang && options.defaultLanguage) {\n        lang = options.defaultLanguage\n        node.properties.className.push(`language-${lang}`)\n      }\n      node.properties.className.push('code-highlight')\n\n      /** @type {Element} */\n      let refractorRoot\n\n      // Syntax highlight\n      if (lang) {\n        try {\n          let rootLang\n          if (lang?.includes('diff-')) {\n            rootLang = lang.split('-')[1]\n          } else {\n            rootLang = lang\n          }\n          // @ts-ignore\n          refractorRoot = refractor.highlight(toString(node), rootLang)\n          // @ts-ignore className is already an array\n          parent.properties.className = (parent.properties.className || []).concat(\n            'language-' + rootLang\n          )\n        } catch (err) {\n          if (options.ignoreMissing && /Unknown language/.test(err.message)) {\n            refractorRoot = node\n          } else {\n            throw err\n          }\n        }\n      } else {\n        refractorRoot = node\n      }\n\n      refractorRoot.children = addNodePositionClosure()(refractorRoot.children)\n\n      // Add position info to root\n      if (refractorRoot.children.length > 0) {\n        refractorRoot.position = {\n          start: { line: refractorRoot.children[0].position.start.line, column: 0 },\n          end: {\n            line: refractorRoot.children[refractorRoot.children.length - 1].position.end.line,\n            column: 0,\n          },\n        }\n      } else {\n        refractorRoot.position = {\n          start: { line: 0, column: 0 },\n          end: { line: 0, column: 0 },\n        }\n      }\n\n      const shouldHighlightLine = calculateLinesToHighlight(meta)\n      const startingLineNumber = calculateStartingLine(meta)\n      const codeLineArray = createLineNodes(refractorRoot.position.end.line)\n\n      const falseShowLineNumbersStr = [\n        'showlinenumbers=false',\n        'showlinenumbers=\"false\"',\n        'showlinenumbers={false}',\n      ]\n      for (const [i, line] of codeLineArray.entries()) {\n        // Default class name for each line\n        line.properties.className = ['code-line']\n\n        // Syntax highlight\n        const treeExtract = filter(\n          refractorRoot,\n          (node) => node.position.start.line <= i + 1 && node.position.end.line >= i + 1\n        )\n        line.children = treeExtract.children\n\n        // Line number\n        if (\n          (meta.toLowerCase().includes('showLineNumbers'.toLowerCase()) ||\n            options.showLineNumbers) &&\n          !falseShowLineNumbersStr.some((str) => meta.toLowerCase().includes(str))\n        ) {\n          line.properties.line = [(i + startingLineNumber).toString()]\n          line.properties.className.push('line-number')\n        }\n\n        // Line highlight\n        if (shouldHighlightLine(i)) {\n          line.properties.className.push('highlight-line')\n        }\n\n        // Diff classes\n        if (\n          (lang === 'diff' || lang?.includes('diff-')) &&\n          toString(line).substring(0, 1) === '-'\n        ) {\n          line.properties.className.push('deleted')\n        } else if (\n          (lang === 'diff' || lang?.includes('diff-')) &&\n          toString(line).substring(0, 1) === '+'\n        ) {\n          line.properties.className.push('inserted')\n        }\n      }\n\n      // Remove possible trailing line when splitting by \\n which results in empty array\n      if (\n        codeLineArray.length > 0 &&\n        toString(codeLineArray[codeLineArray.length - 1]).trim() === ''\n      ) {\n        codeLineArray.pop()\n      }\n\n      node.children = codeLineArray\n    }\n  }\n}\n\nexport default rehypePrismGenerator\n"],
  "mappings": "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",
  "names": ["str", "i", "rehypePrismGenerator", "refractor", "options", "defaultLanguage", "registered", "Error", "tree", "visit", "visitor", "node", "index", "parent", "_node$data", "_node$properties", "tagName", "meta", "data", "properties", "metastring", "className", "Array", "isArray", "refractorRoot", "startLineNum", "lang", "_step", "_iterator", "_createForOfIteratorHelperLoose", "done", "classListItem", "value", "slice", "toLowerCase", "push", "_lang", "rootLang", "includes", "split", "highlight", "toString", "concat", "err", "ignoreMissing", "test", "message", "children", "addNodePosition", "ast", "reduce", "result", "type", "numLines", "match", "length", "position", "start", "line", "column", "end", "_step2", "lines", "_iterator2", "entries", "_step2$value", "i", "Object", "prototype", "hasOwnProperty", "call", "initialLineNum", "_step3", "shouldHighlightLine", "RE", "parsedMeta", "map", "str", "trim", "join", "strlineNumbers", "exec", "lineNumbers", "rangeParser", "startingLineNumber", "_wrapRegExp", "_RE$exec", "Number", "groups", "codeLineArray", "number", "a", "falseShowLineNumbersStr", "_loop", "_lang2", "_lang3", "_step3$value", "treeExtract", "filter", "showLineNumbers", "some", "substring", "_iterator3", "pop"]
}
