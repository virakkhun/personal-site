import {
  SKIP,
  convert,
  visitParents
} from "./chunk-6XJW5YQ2.js";
import {
  whitespace
} from "./chunk-YXGV35TX.js";
import "./chunk-ZC22LKFR.js";

// node_modules/hast-util-is-element/index.js
var isElement = (
  /**
   * @type {(
   *   (() => false) &
   *   (<T extends Element = Element>(node: unknown, test?: PredicateTest<T>, index?: number, parent?: Parent, context?: unknown) => node is T) &
   *   ((node: unknown, test: Test, index?: number, parent?: Parent, context?: unknown) => boolean)
   * )}
   */
  /**
   * @param {unknown} [node]
   * @param {Test | undefined} [test]
   * @param {number | null | undefined} [index]
   * @param {Parent | null | undefined} [parent]
   * @param {unknown} [context]
   * @returns {boolean}
   */
  // eslint-disable-next-line max-params
  function(node2, test, index, parent, context) {
    const check = convertElement(test);
    if (index !== void 0 && index !== null && (typeof index !== "number" || index < 0 || index === Number.POSITIVE_INFINITY)) {
      throw new Error("Expected positive finite index for child node");
    }
    if (parent !== void 0 && parent !== null && (!parent.type || !parent.children)) {
      throw new Error("Expected parent node");
    }
    if (!node2 || !node2.type || typeof node2.type !== "string") {
      return false;
    }
    if ((parent === void 0 || parent === null) !== (index === void 0 || index === null)) {
      throw new Error("Expected both parent and index");
    }
    return check.call(context, node2, index, parent);
  }
);
var convertElement = (
  /**
   * @type {(
   *   (<T extends Element>(test: T['tagName'] | TestFunctionPredicate<T>) => AssertPredicate<T>) &
   *   ((test?: Test) => AssertAnything)
   * )}
   */
  /**
   * @param {Test | null | undefined} [test]
   * @returns {AssertAnything}
   */
  function(test) {
    if (test === void 0 || test === null) {
      return element;
    }
    if (typeof test === "string") {
      return tagNameFactory(test);
    }
    if (typeof test === "object") {
      return anyFactory(test);
    }
    if (typeof test === "function") {
      return castFactory(test);
    }
    throw new Error("Expected function, string, or array as test");
  }
);
function anyFactory(tests) {
  const checks = [];
  let index = -1;
  while (++index < tests.length) {
    checks[index] = convertElement(tests[index]);
  }
  return castFactory(any);
  function any(...parameters) {
    let index2 = -1;
    while (++index2 < checks.length) {
      if (checks[index2].call(this, ...parameters)) {
        return true;
      }
    }
    return false;
  }
}
function tagNameFactory(check) {
  return tagName;
  function tagName(node2) {
    return element(node2) && node2.tagName === check;
  }
}
function castFactory(check) {
  return assertion;
  function assertion(node2, ...parameters) {
    return element(node2) && Boolean(check.call(this, node2, ...parameters));
  }
}
function element(node2) {
  return Boolean(
    node2 && typeof node2 === "object" && // @ts-expect-error Looks like a node.
    node2.type === "element" && // @ts-expect-error Looks like an element.
    typeof node2.tagName === "string"
  );
}

// node_modules/hast-util-embedded/lib/index.js
var embedded = convertElement([
  "audio",
  "canvas",
  "embed",
  "iframe",
  "img",
  "math",
  "object",
  "picture",
  "svg",
  "video"
]);

// node_modules/rehype-minify-whitespace/block.js
var blocks = [
  "address",
  // Flow content.
  "article",
  // Sections and headings.
  "aside",
  // Sections and headings.
  "blockquote",
  // Flow content.
  "body",
  // Page.
  "br",
  // Contribute whitespace intrinsically.
  "caption",
  // Similar to block.
  "center",
  // Flow content, legacy.
  "col",
  // Similar to block.
  "colgroup",
  // Similar to block.
  "dd",
  // Lists.
  "dialog",
  // Flow content.
  "dir",
  // Lists, legacy.
  "div",
  // Flow content.
  "dl",
  // Lists.
  "dt",
  // Lists.
  "figcaption",
  // Flow content.
  "figure",
  // Flow content.
  "footer",
  // Flow content.
  "form",
  // Flow content.
  "h1",
  // Sections and headings.
  "h2",
  // Sections and headings.
  "h3",
  // Sections and headings.
  "h4",
  // Sections and headings.
  "h5",
  // Sections and headings.
  "h6",
  // Sections and headings.
  "head",
  // Page.
  "header",
  // Flow content.
  "hgroup",
  // Sections and headings.
  "hr",
  // Flow content.
  "html",
  // Page.
  "legend",
  // Flow content.
  "li",
  // Block-like.
  "li",
  // Similar to block.
  "listing",
  // Flow content, legacy
  "main",
  // Flow content.
  "menu",
  // Lists.
  "nav",
  // Sections and headings.
  "ol",
  // Lists.
  "optgroup",
  // Similar to block.
  "option",
  // Similar to block.
  "p",
  // Flow content.
  "plaintext",
  // Flow content, legacy
  "pre",
  // Flow content.
  "section",
  // Sections and headings.
  "summary",
  // Similar to block.
  "table",
  // Similar to block.
  "tbody",
  // Similar to block.
  "td",
  // Block-like.
  "td",
  // Similar to block.
  "tfoot",
  // Similar to block.
  "th",
  // Block-like.
  "th",
  // Similar to block.
  "thead",
  // Similar to block.
  "tr",
  // Similar to block.
  "ul",
  // Lists.
  "wbr",
  // Contribute whitespace intrinsically.
  "xmp"
  // Flow content, legacy
];

// node_modules/rehype-minify-whitespace/content.js
var content = [
  // Form.
  "button",
  "input",
  "select",
  "textarea"
];

// node_modules/rehype-minify-whitespace/skippable.js
var skippable = [
  "area",
  "base",
  "basefont",
  "dialog",
  "datalist",
  "head",
  "link",
  "meta",
  "noembed",
  "noframes",
  "param",
  "rp",
  "script",
  "source",
  "style",
  "template",
  "track",
  "title"
];

// node_modules/rehype-minify-whitespace/index.js
var ignorableNode = convert(["doctype", "comment"]);
function rehypeMinifyWhitespace(options = {}) {
  const collapse = collapseFactory(
    options.newlines ? replaceNewlines : replaceWhitespace
  );
  return (tree) => {
    minify(tree, { collapse, whitespace: "normal" });
  };
}
function minify(node2, context) {
  if ("children" in node2) {
    const settings = Object.assign({}, context);
    if (node2.type === "root" || blocklike(node2)) {
      settings.before = true;
      settings.after = true;
    }
    settings.whitespace = inferWhiteSpace(node2, context);
    return all(node2, settings);
  }
  if (node2.type === "text") {
    if (context.whitespace === "normal") {
      return minifyText(node2, context);
    }
    if (context.whitespace === "nowrap") {
      node2.value = context.collapse(node2.value);
    }
  }
  return { remove: false, ignore: ignorableNode(node2), stripAtStart: false };
}
function minifyText(node2, context) {
  const value = context.collapse(node2.value);
  const result = { remove: false, ignore: false, stripAtStart: false };
  let start = 0;
  let end = value.length;
  if (context.before && removable(value.charAt(0))) {
    start++;
  }
  if (start !== end && removable(value.charAt(end - 1))) {
    if (context.after) {
      end--;
    } else {
      result.stripAtStart = true;
    }
  }
  if (start === end) {
    result.remove = true;
  } else {
    node2.value = value.slice(start, end);
  }
  return result;
}
function all(parent, context) {
  let before = context.before;
  const after = context.after;
  const children = parent.children;
  let length = children.length;
  let index = -1;
  while (++index < length) {
    const result = minify(
      children[index],
      Object.assign({}, context, {
        before,
        after: collapsableAfter(children, index, after)
      })
    );
    if (result.remove) {
      children.splice(index, 1);
      index--;
      length--;
    } else if (!result.ignore) {
      before = result.stripAtStart;
    }
    if (content2(children[index])) {
      before = false;
    }
  }
  return { remove: false, ignore: false, stripAtStart: Boolean(before || after) };
}
function collapsableAfter(nodes, index, after) {
  while (++index < nodes.length) {
    const node2 = nodes[index];
    let result = inferBoundary(node2);
    if (result === void 0 && "children" in node2 && !skippable2(node2)) {
      result = collapsableAfter(node2.children, -1);
    }
    if (typeof result === "boolean") {
      return result;
    }
  }
  return after;
}
function inferBoundary(node2) {
  if (node2.type === "element") {
    if (content2(node2)) {
      return false;
    }
    if (blocklike(node2)) {
      return true;
    }
  } else if (node2.type === "text") {
    if (!whitespace(node2)) {
      return false;
    }
  } else if (!ignorableNode(node2)) {
    return false;
  }
}
function content2(node2) {
  return embedded(node2) || isElement(node2, content);
}
function blocklike(node2) {
  return isElement(node2, blocks);
}
function skippable2(node2) {
  return Boolean(
    "properties" in node2 && node2.properties && node2.properties.hidden
  ) || ignorableNode(node2) || isElement(node2, skippable);
}
function removable(character) {
  return character === " " || character === "\n";
}
function replaceNewlines(value) {
  const match = /\r?\n|\r/.exec(value);
  return match ? match[0] : " ";
}
function replaceWhitespace() {
  return " ";
}
function collapseFactory(replace) {
  return collapse;
  function collapse(value) {
    return String(value).replace(/[\t\n\v\f\r ]+/g, replace);
  }
}
function inferWhiteSpace(node2, context) {
  if ("tagName" in node2 && node2.properties) {
    switch (node2.tagName) {
      case "listing":
      case "plaintext":
      case "script":
      case "style":
      case "xmp":
        return "pre";
      case "nobr":
        return "nowrap";
      case "pre":
        return node2.properties.wrap ? "pre-wrap" : "pre";
      case "td":
      case "th":
        return node2.properties.noWrap ? "nowrap" : context.whitespace;
      case "textarea":
        return "pre-wrap";
      default:
    }
  }
  return context.whitespace;
}

// node_modules/hast-util-has-property/lib/index.js
var own = {}.hasOwnProperty;
function hasProperty(node2, field) {
  const value = typeof field === "string" && isNode(node2) && node2.type === "element" && node2.properties && own.call(node2.properties, field) && node2.properties[field];
  return value !== null && value !== void 0 && value !== false;
}
function isNode(value) {
  return Boolean(value && typeof value === "object" && "type" in value);
}

// node_modules/hast-util-is-body-ok-link/index.js
var list = /* @__PURE__ */ new Set(["pingback", "prefetch", "stylesheet"]);
function isBodyOkLink(node2) {
  if (!isElement(node2, "link")) {
    return false;
  }
  if (hasProperty(node2, "itemProp")) {
    return true;
  }
  const props = node2.properties || {};
  const rel = props.rel || [];
  let index = -1;
  if (!Array.isArray(rel) || rel.length === 0) {
    return false;
  }
  while (++index < rel.length) {
    if (!list.has(String(rel[index]))) {
      return false;
    }
  }
  return true;
}

// node_modules/hast-util-phrasing/lib/index.js
var basic = convertElement([
  "a",
  "abbr",
  // `area` is in fact only phrasing if it is inside a `map` element.
  // However, since `area`s are required to be inside a `map` element, and it’s
  // a rather involved check, it’s ignored here for now.
  "area",
  "b",
  "bdi",
  "bdo",
  "br",
  "button",
  "cite",
  "code",
  "data",
  "datalist",
  "del",
  "dfn",
  "em",
  "i",
  "input",
  "ins",
  "kbd",
  "keygen",
  "label",
  "map",
  "mark",
  "meter",
  "noscript",
  "output",
  "progress",
  "q",
  "ruby",
  "s",
  "samp",
  "script",
  "select",
  "small",
  "span",
  "strong",
  "sub",
  "sup",
  "template",
  "textarea",
  "time",
  "u",
  "var",
  "wbr"
]);
var meta = convertElement("meta");
function phrasing(value) {
  return Boolean(
    node(value) && (value.type === "text" || basic(value) || embedded(value) || isBodyOkLink(value) || meta(value) && hasProperty(value, "itemProp"))
  );
}
function node(value) {
  return value && typeof value === "object" && "type" in value;
}

// node_modules/html-whitespace-sensitive-tag-names/index.js
var whitespaceSensitiveTagNames = [
  "pre",
  "script",
  "style",
  "textarea"
];

// node_modules/rehype-format/index.js
var minify2 = rehypeMinifyWhitespace({ newlines: true });
function rehypeFormat(options = {}) {
  let indent = options.indent || 2;
  let indentInitial = options.indentInitial;
  if (typeof indent === "number") {
    indent = " ".repeat(indent);
  }
  if (indentInitial === null || indentInitial === void 0) {
    indentInitial = true;
  }
  return (tree) => {
    let head;
    minify2(tree);
    visitParents(tree, (node2, parents) => {
      let index = -1;
      if (!("children" in node2)) {
        return;
      }
      if (isElement(node2, "head")) {
        head = true;
      }
      if (head && isElement(node2, "body")) {
        head = void 0;
      }
      if (isElement(node2, whitespaceSensitiveTagNames)) {
        return SKIP;
      }
      const children = node2.children;
      let level = parents.length;
      if (children.length === 0 || !padding(node2, head)) {
        return;
      }
      if (!indentInitial) {
        level--;
      }
      let eol;
      while (++index < children.length) {
        const child = children[index];
        if (child.type === "text" || child.type === "comment") {
          if (child.value.includes("\n")) {
            eol = true;
          }
          child.value = child.value.replace(
            / *\n/g,
            "$&" + String(indent).repeat(level)
          );
        }
      }
      const result = [];
      let previous;
      index = -1;
      while (++index < children.length) {
        const child = children[index];
        if (padding(child, head) || eol && !index) {
          addBreak(result, level, child);
          eol = true;
        }
        previous = child;
        result.push(child);
      }
      if (previous && (eol || padding(previous, head))) {
        if (whitespace(previous)) {
          result.pop();
          previous = result[result.length - 1];
        }
        addBreak(result, level - 1);
      }
      node2.children = result;
    });
  };
  function addBreak(list2, level, next) {
    const tail = list2[list2.length - 1];
    const previous = whitespace(tail) ? list2[list2.length - 2] : tail;
    const replace = (blank(previous) && blank(next) ? "\n\n" : "\n") + String(indent).repeat(Math.max(level, 0));
    if (tail && tail.type === "text") {
      tail.value = whitespace(tail) ? replace : tail.value + replace;
    } else {
      list2.push({ type: "text", value: replace });
    }
  }
  function blank(node2) {
    return Boolean(
      node2 && node2.type === "element" && options.blanks && options.blanks.length > 0 && options.blanks.includes(node2.tagName)
    );
  }
}
function padding(node2, head) {
  return node2.type === "root" || (node2.type === "element" ? head || isElement(node2, "script") || embedded(node2) || !phrasing(node2) : false);
}
export {
  rehypeFormat as default
};
//# sourceMappingURL=rehype-format.js.map
